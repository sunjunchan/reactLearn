# State Hook
是一个在函数组件中使用的函数（useState）,用于在函数组件中使用状态
- useState函数有一个参数，这个参数的值表示状态的默认值
- 函数的返回值是一个数组，该数组一定包含两项
  - 第一项，当前状态的值
  - 第二项，改变状态的函数

一个函数组件中可以有多个状态，这种做法非常有利于横向切分关注点。

## State Hook核心原理
1. 当运行一个函数组件时（调用该函数时）
  1. 第N次调用useState
  2. 检查该节点的状态数组是否存在下边N
  3. 不存在
    1. 状态表格中没内容
    2. 使用默认值创建一个状态，下标为N
    3. 将该状态加入状态数组中
  4. 存在
    1. 忽略掉默认值
    2. 直接得到状态值
表格（数组）附着在组件节点（App）上，互补影响
<App></App>
<App></App>

**注意的细节**
1. useState最好写在函数的其实位置，便于阅读
2. useState严禁出现在代码块（判断，循环）中
3. 返回的函数，（数组的第二项），引用不变（节约内存空间）
4. 如果使用函数改变数据，若数据和之前的数据完全相等，（使用Object.is比较）不会导致重新渲染，以达到优化效率的目的
5. 使用函数改变数据，传入的值不回和原来的数据进行合并，而是直接替换。
6. 如果要实现强制刷新组件
  1. 类组件：使用this.forceUpdata(),不会运行sholudComponentUpdata
  2. 函数组件：使用一个空对象的useState
  const [,forceUpdata] = useState({})
一组数据：
setData({
  ...data,
  x: data.x + 1
})
7. **如果某些状态之间没有必然的联系，应该分化为不同的状态，而不要合并成一个对象**
8. 和类组件的状态一样，函数组件中改变状态可能是异步的，（在dom事件中），多个状态变化会合并，以提高效率，此时不能信任之前的状态，应该使用回调函数的方式，改变状态
setN(n+1)//不会立即改变，事件运行完成后一起改变
setN(n+1)//此时，n的值仍然是0
setN(prevN=>prevN+1)传入的函数，在事件完成之后统一运行
setN(prevN=>prevN+1) //此时n是1
如果状态变化要使用之前的变化，尽量传递函数